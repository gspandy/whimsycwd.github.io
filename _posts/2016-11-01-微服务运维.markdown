---
layout: post
title:  "微服务运维实践-平滑上线[重新整理]"
date:   2016-11-01 
categories: microservice
---

## 0. 概要


一句话概括本文工作`利用前端负载均衡， 和微服务调用框架的参数透传, 实现局部模块升级的灰度发布方案` 

该工作有如下收益

1. 大大提升运维效率
	-	多人协助上线， 有互相依赖的上线 => 单人上线
	-	多人工操作 => 一键上线
	-	提供一键回滚的方案
	- 	上线所需成本降低， `上线流程化`， 由值日生进行上线
2. 提供预发布环境
	-	上线后， `验证人员在预发布环境中进行功能验证`
3. 平滑升级， 在上线工程中， 用户不感知， 流量切换上线在秒级别完成

## 1. 背景

### 1.1 微服务调用框架Navi-rpc 

[Github Repo](https://github.com/neoremind/navi)


Navi是一个分布式服务框架，提供高性能和无侵入式的RPC远程服务调用方案，以及SOA服务治理方案.
**其中， 该框架对于服务的版本没有提供支持**， 需要用户显式修改服务提供方的注册路径以及调用路径来进行版本管理。 
服务治理还处于一个比较粗糙的阶段， 人工地在上线阶段修改版本容易引入错误。 我们在早期使用的框架的过程中， 选择替换上线，即**服务单版本**。 

1. 这就带来一个问题， 服务的升级需要严格前向兼容， 开发时严格的前向兼容带来了开发效率低下的问题
2. 在服务单版本的前提下， 如果服务的升级不前向兼容， 那么在上线过程中， 会出现服务报错的情况。 这也是难以接受的


### 1.2 上线工具支持滞后

1. 云平台JPaaS并没有把微服务作为一等公民， 并没有考虑到一个产品会有20+个模块。 Web上线平台包含大量人工。 
2. 另外， 因为我们的服务调用框架采用的是进程内负载均衡的方案， PaaS平台并不能控制内部调用的调用， 因而难以提供平台粒度的灰度发布方案。 
3. 同时模块数量， 以及模块间的依赖使得， 上线和回滚十分复杂。 上线人员需要对模块依赖有了解。 

## 2 方案设计
![灰度发布架构总览](/image/20161101/abtest-overview.png)


灰度发布是指黑与白之间， 能够平滑过渡的一种发布方式

在这个场景里， 有三种角色， 在图中的顶部 DevOps, 媒体， 验证人员。 

1.	媒体通过浏览器发起请求， 请求经过 BFE 转发到v1 的边缘服务， 边缘服务调用v1 的内部通用服务V1 是线上的稳定的发布版本。 
2.	验证人员在预发布时， 请求经过BFE 转发到v2 的边缘服务， 边缘服务调用v2 的内部通用服务V2 是新上线的待验证发布版本。 
3.	DevOps 通过上线程序控制BFE的转发规则来控制用户对边缘服务的访问。 另外上线程序通过Disconf的配置管理来控制边缘服务和内部服务对下游的调用。  

### 2.1 依赖组件

1. Disconf [Github Repo](https://github.com/knightliao/disconf)Distributed Configuration Management Platform(分布式配置管理平台).  **通过利用Zookeeper Watcher 来实现， Java 应用程序的配置的不停机更新**
2. Baidu Front End [related report](http://www.linuxeden.com/html/news/20160118/164420.html) 百度统一前端， 是百度的流量接入平台， 统一考虑流量调度， 安全和防攻击等。  **我在使用的时候， 把BFE当成升级版的反向代理nginx, 提供Open API 操作流量调度， 规则包括， 根据用户在浏览器设置的Cookie 来进行流量转发**
3. JPaaS(Join the Platform-as-a-Service ecosystem) 百度运维部产品， 内部云平台， **支持Open API 调度应用和实例**。 
4. BNS(Baidu Naming Service) 百度名称服务，类似于DNS提供域名到IP的映射，提供服务名称或服务组名称到服务所有运行实例的映射等

### 2.2 流量标记

![灰度发布-流量标记](/image/20161101/mark_traffic.png)

1.  验证人员在访问预发布环境的时候, 会设置Cookie， 这个动作标记了流量
2.  BFE 根据请求中的Cookie 信息， 选择边缘服务
3.  微服务框架采用进程内LB的方案， 所以不仅要在反向代理层做预发布流量的标记, 还需要在服务调用时， 控制流量转发到预发布的机器。 
4.  通过升级Navi-Rpc 的`服务选择` 模块,  透传上下文对象 详细方案见下
	-  进行RPC调用时， 传递上下文信息对象 RpcContext.java
	-  服务在调用时， 根据RpcContext.java 里设置的信息， 选择相应的服务注册路径。 
5.  设计的流量标记的方案， 可以得到的 **精细地局部升级**， 具体地说， 就是可以使用一个新上的服务加上原有的其他服务组成一个新的环境。 



### 2.3 流量切换

![灰度发布-流量切换](/image/20161101/change_traffic.png)

1. 验证通过后， 需要发布流量， 普通用户是不会主动输入模块的版本信息的
2. 对于边缘服务， 通过调用BFE 的Open API 来实现流量的切换
3. 对于内部服务， 通过Disconf 向正在运行的后端边缘服务推送配置。 后端边缘服务在向下调用的时候， 将推送来的信息放入上下文对象中。 
4. 通过切流量的方式完成上线和回滚。 可以几乎瞬时完成， 对用户影响极小


### 2.4 前向兼容

![灰度发布-向后兼容](/image/20161101/compatible.png)

1. 对于这样一个方案， 多产品(边缘服务) 难以同步完成迁移
2. 对于CT任务等服务上游， 不希望引入BFE 和 Disconf 等依赖
3. 我们通过实例在服务注册中心的多注册和运行时更改注册内容来保证了兼容， 对于不希望迁移的模块和代码， 能够按照旧的方式存在， 不影响其使用
	-	分布式配置中心管理兼容的服务版本信息，在改变时推送事件到运行的实例
	-   服务实例得到事件做对应的注册和撤销


## 3 上线工具

![灰度发布-上线程序](/image/20161101/ship-flow.png)

1. 上线程序的设置目标
	-	便捷， 尽量没有人工
	-	安全， 避免误操作
2. 上线程序包含一下基本动作和概念
	-   **[会话]** 所有的上线内容为一次会话， 上线和回滚的对象为会话， **大大减少上线所需信息**
	-   **[输入]** 编译模块得到的上线内容， 编译产物
	-   **[验证]** 得到Cookie 来访问线上的预发布环境
	-   **[发布]** 将预发布环境设置为正式环境
	-   **[回滚]** 将正式环境回滚到本次上线前的状态
3. 上线工具接口一览

<pre>
abt2 start 
    判断的会话状态
    1. 会话正在进行中， 不能新建会话
    2. 会话已经提交， 但是并没有结束， 联系之前的操作人确认
    3. 可以安全开始新会话
abt2 start create --op=${op_name} --desp=${description}
    开始新的会话
    1.  --desp 为可选项， 非正常迭代上线请填写
}
abt2 config put --op=${op_name} --name=${module_name} --path=${war_path} [--init=true]
    配置一个新的模块
    1. 会根据程序历史上线信息生成一个配置信息， 包含要上线的目标app等信息
    2. --init=true 为可选， 当新增一个以前不存在的模块的时候需要
abt2 ship --op=${op_name}
    列出所有待上线的模块和内容
abt2 ship all  --op=${op_name}
    上线所有待上线模块
abt2 ship ${module_1} ${module_2} ...
    指定模块上线
abt2 status 
    列举出当前的活跃状态
    1. 如果是会话进行中， 则列出线上环境和预发布环境， 以及访问预发布环境要用的cookie
    2. 如果是会话已提交， 则列出线上环境和备份环境， 以及可访问备份环境用的cookie
    3. 如果会话已结束， 则列出线上环境
abt2 commit --op=${op_name}
    提交会话
    1. 切换Bfe 
    2. 切换disconf 
abt2 rollback --op=${op_name}
    回滚会话
    1. 回滚Bfe
    2. 回滚disconf 
abt2 clean --op=${op_name}
    结束会话
    1. 下线备份环境， 下线后不能回滚了。 可以开始新的会话
abt2 validate [--jpaas=true] [--bfe=true] [--disconf=true] [--all=tre]
    验证本地的状态信息和远程的状态信息， 如果有差异会列出差异
abt2 refresh --op=${op_name}
    当本地状态信息和远程不同步， 可能因为
    1. 误操作
    2. 程序调用远程接口时的网络错误
    对于disconf 和 bfe 配置， refresh 可使得远程的信息和本地同步
    **[Dev folks Only]**
</pre>

## 4. 总结
微服务实践以来的一个体会是， 很多以前简单的事情变复杂了。 采用微服务一个比较公认重要的好处是， 因为模块相对小， 能够快速迭代。 然而在使用的过程中我认为无论是上线还是开发都变得复杂了， 如果没有相应的方法论的沉淀和工具的辅助， 子系统的迭代开发也做不到像想象中那么敏捷。 本文工作是对上线工作简化的一个尝试。 `这种方法解决了SSP的问题, 但是实现方案不具有普适性。` 


