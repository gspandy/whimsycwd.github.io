---
layout: post
title:  "PaaS + 服务网络"
date:   2017-03-16 13:00:00 +0800
categories: microservice mesh paas
---

## TOC

1. 项目背景
	- 微服务痛点
	- 人与微服务
2. 具体痛点场景
	- 多模块上线
	- 多产品上线
	- 端到端验证
	- 总结
3. PaaS-服务网络
	- 涉及要点
	- 业务功能
	- 总体方案
	- core(Linkerd)工作机制

4. 展望&总结



## 1. 项目背景

### 1.1 微服务痛点
![微服务痛点](/image/mesh/the-hardest-part-of-microservices-your-data-christian-posta-red-hat.jpg)

微服务的实践需要很多公共基础组件。 

* 	包括服务调用框架(navi-rpc), 
*   日志追踪， 问题排查
*   分布式配置管理
*   发布变更
*   ...

本文关注其中的发布变更这一主题

1. 由于服务数量的增加， 业务在上线的时候， 需要上线大量的模块。 现在常见的做法是， **需要有专人梳理上线依赖**
2.  模块需要按照顺序进行上线。 同时上线当时， 很多时候是各个模块的Owner 负责上线。 **上线过程中invole 了大半组人** 
3. 以往在单体应用种用得很好得功能机制， 在微服务中失效。 由于各个App 单独上线， 有一些端到端得功能验证必须等所有模块上完之后才能验证。 **缺乏灰度验证机制** 
4. 和上线变更一样， 回滚变更也非常复杂。 由于, 服务间调用负载均衡得存在， 入口网关不再能控制流量。 不能通过切流量完成回滚。 服务回滚， **需要进行上线得退栈操作**, 由于这个复杂性， 很多情况下， 回滚会用重新上线历史上线包来完成。

微服务的引入， 使得， PaaS 提供的单APP 的预发布， 回滚机制。 并不能很好地被使用。 在微服务地背景下， `上线, 回滚， 灰度发布应该需要重现定义和实现`

### 1.2 人与微服务
[Conway Law](https://www.thoughtworks.com/insights/blog/demystifying-conways-law)

> Any organization that designs a system (defined more broadly here than just information systems) will inevitably produce a design whose structure is a copy of the organization's communication structure.


服务的依赖关系， 包括边界和团队的组织关系， 最终回反应组织架构。 Conway 法则强调了”人“。
我们仔细分析一下人与服务的关系。 可以发现， 人并不和服务有直接的关系。 产品经理是产品的， 测试也是产品的。 KPI 同样如此。 考虑运维发布场景， 一系列在PaaS 上的比昂更都是围绕产品进行的。 

`因此， 运维工具如果只停留在服务这一层级， 会造成极大不便`.


## 2. 具体场景痛点 

1. PaaS 对微服务支持有限
	- 目前， JPaaS 只提供了单App的发布方案
	- 多APP 的上线和回滚没有工具的支持
	- 上线时需要根据服务的拓扑顺序上线
	- 回滚时需要了解代码依赖关系， 进行局部回滚
	- **涉及多人协作**
	- **多人工操作**
	- **对上线人要求高**

2. 没有微服务的预发布方案
	- 上线后，**验证人员验证系统同时， 用户流量同时可访问系统** 
3. 升级不平滑
	- 升级不平上线中影响用户操作, 影响期长
4. 接口开发需严格兼容
	- 服务化之后，接口爆炸， 且多数接口相对私有

接下来就三个场景展开讨论痛点

### 2.1 多模块上线

1. 业务导向的业务开发Feature 很容易垮模块
2. 并不会以 Feature 粒度进行上线， 往往是以 Sprint 为单位进行迭代上线
3. 一次上线往往会设计很多模块
4. 模块上线需要按照以来书序， 自底向上
5. 模块开发需要保证兼容

以上， 结合在网盟三年的微服务实践， 我认为微服务在变更发布时需要有多模块同时上线的工具。 

值得注意的权威大神Matin Fowler认为的微服务的独立部署性是非常重要的。
> The ability to deploy services independently is part of the definition of microservices. So it's reasonable to say that a suite of services that must have its deployments coordinated is not a microservice architecture. It is also reasonable to say that many teams that attempt a microservice architecture get into trouble because they end up having to coordinate service deployments.

也有和几位微服务布道者进行交流， 也都强调独立部署性。 但同时也提到微服务带来的运维复杂度。 `@Attention` 于我个人实践经验讲， 合理地抽象， 开发工具来进行多模块上线是有意义的。 


### 2.2 多产品上线

![多产品上线](/image/mesh/multi-product.png)

1. 同一个产品线的不同产品从复用代码的角度公用统一服务
2. 不同产品由不同团队维护， 有各自的迭代开发节奏
3. 回滚痛点(Accout 模块出现问题需要回滚， 这个时候需要开发人员分析影响面进行回滚)， 注意到， 可能会涉及跨产品的回滚。 

举我们出国的一次P0事故， ssp 做了一次账号的升级， 引入了一个bug 给账号服务， 某些特征的账户不能够登录系统。 上线后没有发现该bug, 第二天大量的union客户来进行反馈。 (union 是变现产品， 企业客户， 专门运营)

`注意到这个时候union.baidu.com 是被动升级， 他们设置没有流程让他们进行一个上线后的验证`

再举一个例子， 假如某一个bug只影响ssp 的用户。 这个时候， 回滚需要通知别的产品一同进行回滚。 造成级连回滚。 


### 2.3 端到端验证

![蓝绿发布](/image/mesh/blue-green.png)

预发布是一个成熟的发布流程中必备的一步。 微服务后如何做线上的多模块的预发布? 

1. 如上图左， 一般的蓝绿发布， 通过部署两份隔离环境， 通过最上层网关流量切换来完成线上的多版本。这样的蓝绿发布不通用， 有运维成本， 只有大产品才会有专属的OP设计和实施这个计划方案。这会造成资源(机器+时间)的浪费。  
	
	- 机器资源浪费: 一般意义的蓝绿环境时等价的。 意味着上线时需要两倍的资源。 在公有集群可能可以。 但是矛盾的事， 专门的蓝绿发布方案只会为大产品定制。大产品都是私有集群。 
	- 时间的浪费: 实战中遇到一种变形， 沙盒发布。 沙盒环境是部署机器比较少的一个环境。 验证通过之后。 再在正式环境再上一遍。 这意味着上两次线。 在目前上线需要排队上线的情形下， 会造成极大的时间浪费

2. 如上右图， 两个环境通过局部的共享服务(A-service), 可以做到局部发布。 举个例子， 假如业务有20个服务， 某次迭代更新5 个服务。 那么只需要上线5个服务。 旧的20个服务为一个环境。 旧的15个服务加上这被更新的5个服务组成新的环境. 

除了资源上的考虑。 `整体的蓝绿发布没有办法处理多产品的情形`




## 3. PaaS-服务网络

基于对以上痛点的分析， 我们可以看到， 在实践微服务过程中， 需要有平台和工具来解决运维发布的工具。 来解决微服务带来的运维复杂度， 实现多产品独立发布和回滚预发布的机制， 来提高发布效率和安全性。 

### 3.1 设计要点

1. 微服务框架中立=>语言中立(接入)
2. 对业务侵入小(接入)
3. 对性能损失影响小(接入)
4. PaaS 要有足够的流量控制权(实现功能)
5. 支持服务的多版本， 多产品的上线接耦合， 多版本回滚(功能)
6. 产品化(使用)

### 3.2 业务功能
开发时以模块为核心， 变更时以产品为核心

#### 3.2.1 微服务组织结构
开发时以模块为核心, 但是变更时以产品为核心

- 产品线(org): 对应一个产品集合
- 产品(product): 通常对应一个域名或者App, 对应一组
- 模块(Module): 按照微服务的方法论拆分的可服用模块， 比如通用账号， 或者通用报表服务

PaaS 提供元信息的录入， 包产品， 模块的增删改查


#### 3.2.2 上线变更

上线单(tikcet): 或者叫一次会话。 记录了一次上线， 通常对应了一次Sprint 的若干feature

1. 选择产品， 变更隶属于某个产品
2. 新建上线单, 上线单是变更的基本操作单元
3. 选择待上线模块的模块列表， 选择镜像版本
4. 根据上线单， 发布服务， 预发布
5. 验证不通过， 修正某些模块(3), 重复4,5


#### 3.2.3 回滚变更

1. 选择产品, 变更隶属于产品
2. 选择历史上线单， PaaS 按照时间顺序列出详细的上线单。
3. 根据历史上线单， 产生新的相同上线单(参考GIT Revert), 不消除public history
4. 接下来进入上线变更的步骤


#### 3.2.4. 预发布

根据上线单, 生成访问预发布环境的header 配置。
使用Chrome ModHeader 插件

#### 3.2.5 多产品服务(多产品共享服务)

服务版本收敛， 注意到服务可能隶属于多个产品
在 “输入上线模块， 填入镜像版本的时候”， 如果发现镜像仓库的地址在同一集群已经上线过已经上线过， 那么直接跳过实例部署的阶段。
这样的方法， 可以收敛多版本服务， 避免同一服务的重复部署， 方便管理


#### 3.2.6 实例回收
业务无需即时下线历史实例。
根据产品历史上线会话， 进行引用计数， 保证业务可以向后回滚n个会话。 N 根据业务特点以及业务资源量进行定义.

#### 3.2.7 镜像构建和发布
TODO

### 3.3 总体方案


![服务网络-总](/image/mesh/mesh.png)
![服务网络-具体](/image/mesh/linkerd.png)
- 用户和验证人员访问同一个线上环境
- 多个产品共用服务
- 同一个服务在线上存在多个版本
- 服务间的调用都经过服务网络(linkerd), 由服务网络来对流量进行调度
- 开发， 只需制定服务之间的依赖， 只制定`逻辑名称`， 比如， 产品A 依赖report 服务，但是并不管线上实际的流量下发。 
- 平台写入流量转发规则来控制。 流量规则用来将`逻辑名称` 转化为`具体名称`
- 开发不需要关注服务注册， 复用k8s 的服务发现。 用这部分信息将`具体名称` 转化为`物理地址`
- 服务网络linerd 接受 namerd 下发的 流量转发规则 和 实例信息， 结合复杂规则进行流量的调度


### 3.4 core(Linkerd)工作机制
![服务网络工作机制](/image/mesh/linkerd2.png)

前身 twitter finagle. 现在 Buyant.io linkerd

Twitter 4-5 年的开发运维 , 克服finagle 的依赖JVM的缺陷

去年3月份开始做 目前1590 个星


#### 3.4.1 微服务的动态链接器

- 	一个基于Layer 5 的组件。 可以获取到请求信息。因此可以做如下的事情
	*	根据 Latency 做负载均衡
	*   根据相应头， 做 Circuit Breaking
	*	根据资源路径信息， 做流量下发。 路由， 广义地说就是服务发现
	*	跨语言的分布式tracing & logging
-  可以做到网关的作用(其实是一个分布式的网关)
	* 	动态路由， 运行时切换流量， 可以用来做Carnery, Staging, Per-Request Routing

#### 3.4.2 路由

路由流程图见上图
- Identification 给请求设置一个路径。 (Input: Request, Ouput: Path)
	*  (i.e 比如把 Header 或者 Host) 根据一定的策略得到路径
	*  ex: http://hello/...  可以把 hello 设置为路径. 
- Delegation 把Path 从逻辑名称(Logical Name)根据Dtab, 扩展出一个具体路径(Concrete Name).
	*   [Dtab](https://linkerd.io/in-depth/dtabs/) 是一个表达能力很强的设计
		-  可以表达机房， 地区。
		-  给流量设置权重
		-  设置通配符号， 多匹配
		-  可以设置忽略规则
		-  有failback 规则， 如果新加的规则， 不能解析到一个具体路径， 会使用以前的规则
	*	运维需要的大量手段， 可以通过Dtab 实现
	*   **这是一个非常重要的组件**
-  Binding 把具体名称(Concrete Name) 绑定到Address(ip:port)
-  Load Balancing 负载均衡
	*   Linker 是一个在 Layer 5 的组件， 而不是Layer 4 的组件。 基于请求应答， 可以拿到更多的性能信息。 
	*   根据请求延时， 做更好的负载策略


## 3.4.3 服务发现

Linkerd 支持基于多种服务发现机制， 提供一下几种常用插件。 这块如果需要可以定制插件。 
- 基于文件的服务发现机制, 不可动态修改， 不适合生产环境使用
- 固定规则的rewrite
- 分布式HA 组件
	*	Zookeeper
	*	Consul
	*	Zookeeper Leaser?
	*	Curator
-  底层架构
	* 	Marathon service discovery
	*   Kubernetes service discovery **What we focus**

我们重点关注基于kubernetes 的服务发现方案



## 5. 总结

本文通过对微服务实践过程中遇到的痛点进行分析， 论证了微服务批量发布， 以及多产品发布， 局部预发布的必要性。
使用开源项目linkerd 作为内部服务网络支撑， 设计了一个在解决以上这些问题的PaaS功能。 linkerd 设计良好， 使得整体方案，同时具备了`语言中立`, `业务侵入小`, `性能损失小` 的特性， 保证了方案的普适性。 其中服务网络把目前放在微服务框架lib 中的服务发现和负载均衡下移。 可以解决多语言的服务框架的重复开发服务发现和负载均衡。 同时likerd 作为一个网关，还可以做日志收集, circuit breaking 等高级特性。

